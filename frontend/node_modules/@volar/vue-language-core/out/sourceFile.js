Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFile = void 0;
const reactivity_1 = require("@vue/reactivity");
const sourceMaps_1 = require("./utils/sourceMaps");
const code_gen_1 = require("@volar/code-gen");
;
function createSourceFile(fileName, _content, vueCompilerOptions, ts, plugins) {
    // refs
    const fileContent = (0, reactivity_1.ref)('');
    const sfc = (0, reactivity_1.reactive)({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
        get templateAst() {
            var _a;
            return (_a = compiledSFCTemplate.value) === null || _a === void 0 ? void 0 : _a.ast;
        },
        get scriptAst() {
            return scriptAst.value;
        },
        get scriptSetupAst() {
            return scriptSetupAst.value;
        },
    }) /* avoid Sfc unwrap in .d.ts by reactive */;
    // use
    const scriptAst = (0, reactivity_1.computed)(() => {
        if (sfc.script) {
            return ts.createSourceFile(fileName + '.' + sfc.script.lang, sfc.script.content, ts.ScriptTarget.Latest);
        }
    });
    const scriptSetupAst = (0, reactivity_1.computed)(() => {
        if (sfc.scriptSetup) {
            return ts.createSourceFile(fileName + '.' + sfc.scriptSetup.lang, sfc.scriptSetup.content, ts.ScriptTarget.Latest);
        }
    });
    const parsedSfc = (0, reactivity_1.computed)(() => {
        var _a;
        for (const plugin of plugins) {
            const sfc = (_a = plugin.parseSFC) === null || _a === void 0 ? void 0 : _a.call(plugin, fileName, fileContent.value);
            if (sfc) {
                return sfc;
            }
        }
    });
    const compiledSFCTemplate = (0, reactivity_1.computed)(() => {
        var _a, _b;
        if (sfc.template) {
            for (const plugin of plugins) {
                const errors = [];
                const warnings = [];
                let ast;
                try {
                    ast = (_b = (_a = plugin.compileSFCTemplate) === null || _a === void 0 ? void 0 : _a.call(plugin, sfc.template.lang, sfc.template.content, Object.assign({ onError: (err) => errors.push(err), onWarn: (err) => warnings.push(err), expressionPlugins: ['typescript'] }, vueCompilerOptions.experimentalTemplateCompilerOptions))) === null || _b === void 0 ? void 0 : _b.ast;
                }
                catch (e) {
                    const err = e;
                    errors.push(err);
                }
                if (ast || errors.length) {
                    return {
                        errors,
                        warnings,
                        ast,
                    };
                }
            }
        }
    });
    // computeds
    const pluginEmbeddedFiles = plugins.map(plugin => {
        const embeddedFiles = {};
        const files = (0, reactivity_1.computed)(() => {
            if (plugin.getEmbeddedFileNames) {
                const embeddedFileNames = plugin.getEmbeddedFileNames(fileName, sfc);
                for (const oldFileName of Object.keys(embeddedFiles)) {
                    if (!embeddedFileNames.includes(oldFileName)) {
                        delete embeddedFiles[oldFileName];
                    }
                }
                for (const embeddedFileName of embeddedFileNames) {
                    if (!embeddedFiles[embeddedFileName]) {
                        embeddedFiles[embeddedFileName] = (0, reactivity_1.computed)(() => {
                            const file = {
                                fileName: embeddedFileName,
                                capabilities: {
                                    diagnostics: false,
                                    foldingRanges: false,
                                    formatting: false,
                                    documentSymbol: false,
                                    codeActions: false,
                                    inlayHints: false,
                                },
                                isTsHostFile: false,
                                codeGen: new code_gen_1.CodeGen(),
                                teleportMappings: [],
                            };
                            for (const plugin of plugins) {
                                if (plugin.resolveEmbeddedFile) {
                                    plugin.resolveEmbeddedFile(fileName, sfc, file);
                                }
                            }
                            return file;
                        });
                    }
                }
            }
            return Object.values(embeddedFiles);
        });
        return (0, reactivity_1.computed)(() => {
            return files.value.map(_file => {
                const file = _file.value;
                const sourceMap = new sourceMaps_1.EmbeddedFileSourceMap();
                for (const mapping of file.codeGen.mappings) {
                    const vueRange = embeddedRangeToVueRange(mapping.data, mapping.sourceRange);
                    let additional;
                    if (mapping.additional) {
                        additional = [];
                        for (const add of mapping.additional) {
                            const addVueRange = embeddedRangeToVueRange(mapping.data, add.sourceRange);
                            additional.push(Object.assign(Object.assign({}, add), { sourceRange: addVueRange }));
                        }
                    }
                    sourceMap.mappings.push(Object.assign(Object.assign({}, mapping), { sourceRange: vueRange, additional }));
                }
                const embedded = {
                    file,
                    sourceMap,
                    teleport: new sourceMaps_1.Teleport(file.teleportMappings),
                };
                return embedded;
            });
        });
    });
    const allEmbeddeds = (0, reactivity_1.computed)(() => {
        const all = [];
        for (const embeddedFiles of pluginEmbeddedFiles) {
            for (const embedded of embeddedFiles.value) {
                all.push(embedded);
            }
        }
        return all;
    });
    const teleports = (0, reactivity_1.computed)(() => {
        const _all = [];
        for (const embedded of allEmbeddeds.value) {
            if (embedded.teleport) {
                _all.push({
                    file: embedded.file,
                    teleport: embedded.teleport,
                });
            }
        }
        return _all;
    });
    const embeddeds = (0, reactivity_1.computed)(() => {
        const embeddeds = [];
        let remain = [...allEmbeddeds.value];
        while (remain.length) {
            const beforeLength = remain.length;
            consumeRemain();
            if (beforeLength === remain.length) {
                break;
            }
        }
        for (const e of remain) {
            embeddeds.push({
                self: e,
                embeddeds: [],
            });
            if (e.file.parentFileName) {
                console.error('Unable to resolve embedded: ' + e.file.parentFileName + ' -> ' + e.file.fileName);
            }
        }
        return embeddeds;
        function consumeRemain() {
            for (let i = remain.length - 1; i >= 0; i--) {
                const embedded = remain[i];
                if (!embedded.file.parentFileName) {
                    embeddeds.push({
                        self: embedded,
                        embeddeds: [],
                    });
                    remain.splice(i, 1);
                }
                else {
                    const parent = findParentStructure(embedded.file.parentFileName, embeddeds);
                    if (parent) {
                        parent.embeddeds.push({
                            self: embedded,
                            embeddeds: [],
                        });
                        remain.splice(i, 1);
                    }
                }
            }
        }
        function findParentStructure(fileName, strus) {
            var _a;
            for (const stru of strus) {
                if (((_a = stru.self) === null || _a === void 0 ? void 0 : _a.file.fileName) === fileName) {
                    return stru;
                }
                let _stru = findParentStructure(fileName, stru.embeddeds);
                if (_stru) {
                    return _stru;
                }
            }
        }
    });
    update(_content);
    return {
        fileName,
        get text() {
            return fileContent.value;
        },
        set text(value) {
            update(value);
        },
        get compiledSFCTemplate() {
            return compiledSFCTemplate.value;
        },
        get tsFileName() {
            var _a, _b;
            return (_b = (_a = allEmbeddeds.value.find(e => e.file.fileName.replace(fileName, '').match(/^\.(js|ts)x?$/))) === null || _a === void 0 ? void 0 : _a.file.fileName) !== null && _b !== void 0 ? _b : '';
        },
        get sfc() {
            return sfc;
        },
        get embeddeds() {
            return embeddeds.value;
        },
        get allEmbeddeds() {
            return allEmbeddeds.value;
        },
        get teleports() {
            return teleports.value;
        },
    };
    function embeddedRangeToVueRange(data, range) {
        var _a;
        if (data.vueTag === 'scriptSrc') {
            if (!((_a = sfc.script) === null || _a === void 0 ? void 0 : _a.src))
                throw '!sfc.script?.src';
            const vueStart = fileContent.value.substring(0, sfc.script.startTagEnd).lastIndexOf(sfc.script.src);
            const vueEnd = vueStart + sfc.script.src.length;
            return {
                start: vueStart - 1,
                end: vueEnd + 1,
            };
        }
        else if (data.vueTag === 'script') {
            if (!sfc.script)
                throw '!sfc.script';
            return {
                start: range.start + sfc.script.startTagEnd,
                end: range.end + sfc.script.startTagEnd,
            };
        }
        else if (data.vueTag === 'scriptSetup') {
            if (!sfc.scriptSetup)
                throw '!sfc.scriptSetup';
            return {
                start: range.start + sfc.scriptSetup.startTagEnd,
                end: range.end + sfc.scriptSetup.startTagEnd,
            };
        }
        else if (data.vueTag === 'template') {
            if (!sfc.template)
                throw '!sfc.template';
            return {
                start: range.start + sfc.template.startTagEnd,
                end: range.end + sfc.template.startTagEnd,
            };
        }
        else if (data.vueTag === 'style') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start + sfc.styles[data.vueTagIndex].startTagEnd,
                end: range.end + sfc.styles[data.vueTagIndex].startTagEnd,
            };
        }
        else if (data.vueTag === 'customBlock') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start + sfc.customBlocks[data.vueTagIndex].startTagEnd,
                end: range.end + sfc.customBlocks[data.vueTagIndex].startTagEnd,
            };
        }
        return range;
    }
    function update(newContent) {
        if (fileContent.value === newContent)
            return;
        fileContent.value = newContent;
        // TODO: wait for https://github.com/vuejs/core/pull/5912
        if (parsedSfc.value) {
            updateTemplate(parsedSfc.value.descriptor.template);
            updateScript(parsedSfc.value.descriptor.script);
            updateScriptSetup(parsedSfc.value.descriptor.scriptSetup);
            updateStyles(parsedSfc.value.descriptor.styles);
            updateCustomBlocks(parsedSfc.value.descriptor.customBlocks);
        }
        function updateTemplate(block) {
            var _a;
            const newData = block ? {
                tag: 'template',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'html',
            } : null;
            if (sfc.template && newData) {
                updateBlock(sfc.template, newData);
            }
            else {
                sfc.template = newData;
            }
        }
        function updateScript(block) {
            var _a;
            const newData = block ? {
                tag: 'script',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'js',
                src: block.src,
            } : null;
            if (sfc.script && newData) {
                updateBlock(sfc.script, newData);
            }
            else {
                sfc.script = newData;
            }
        }
        function updateScriptSetup(block) {
            var _a;
            const newData = block ? {
                tag: 'scriptSetup',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'js',
            } : null;
            if (sfc.scriptSetup && newData) {
                updateBlock(sfc.scriptSetup, newData);
            }
            else {
                sfc.scriptSetup = newData;
            }
        }
        function updateStyles(blocks) {
            var _a;
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const newData = {
                    tag: 'style',
                    start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                    end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                    startTagEnd: block.loc.start.offset,
                    endTagStart: block.loc.end.offset,
                    content: block.content,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'css',
                    module: typeof block.module === 'string' ? block.module : block.module ? '$style' : undefined,
                    scoped: !!block.scoped,
                };
                if (sfc.styles.length > i) {
                    updateBlock(sfc.styles[i], newData);
                }
                else {
                    sfc.styles.push(newData);
                }
            }
            while (sfc.styles.length > blocks.length) {
                sfc.styles.pop();
            }
        }
        function updateCustomBlocks(blocks) {
            var _a;
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const newData = {
                    tag: 'customBlock',
                    start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                    end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                    startTagEnd: block.loc.start.offset,
                    endTagStart: block.loc.end.offset,
                    content: block.content,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'txt',
                    type: block.type,
                };
                if (sfc.customBlocks.length > i) {
                    updateBlock(sfc.customBlocks[i], newData);
                }
                else {
                    sfc.customBlocks.push(newData);
                }
            }
            while (sfc.customBlocks.length > blocks.length) {
                sfc.customBlocks.pop();
            }
        }
        function updateBlock(oldBlock, newBlock) {
            for (let key in newBlock) {
                oldBlock[key] = newBlock[key];
            }
        }
    }
}
exports.createSourceFile = createSourceFile;
//# sourceMappingURL=sourceFile.js.map